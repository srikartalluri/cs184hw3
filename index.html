<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c13{padding-top:18pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:center}.c15{padding-top:18pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c10{padding-top:24pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:center}.c5{padding-top:20pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c4{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:16pt;font-family:"Arial";font-style:normal}.c7{color:#121212;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:23pt;font-family:"Arial";font-style:normal}.c6{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:20pt;font-family:"Arial";font-style:normal}.c9{color:#000000;font-weight:400;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c11{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c14{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c3{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;text-decoration:underline}.c8{color:inherit;text-decoration:inherit}.c2{height:11pt}.c12{font-weight:700}.c16{text-indent:36pt}.c17{height:16pt}.c18{color:#1155cc}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c14 doc-content"><div><p class="c1 c2"><span class="c0"></span></p></div><h1 class="c10" id="h.mg9u5axurju5"><span class="c7">CS 184/284A: Computer Graphics and Imaging, Spring 2024</span></h1><h1 class="c10" id="h.i0bqn14qmjhi"><span class="c7">Homework 3: Pathtracer</span></h1><h2 class="c13" id="h.tlp6ttvzvlbx"><span class="c4">Srikar Talluri 3036580613</span></h2><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c11"><span class="c0">Hosted at:</span></p><p class="c11"><span class="c3 c18"><a class="c8" href="https://www.google.com/url?q=https://srikartalluri.github.io/cs184hw3/&amp;sa=D&amp;source=editors&amp;ust=1710461540594625&amp;usg=AOvVaw3lVyDmUh8p9G0-8Huhk29B">https://srikartalluri.github.io/cs184hw3/</a></span></p><p class="c11"><span>(my classroom repo was not letting me set up pages sry)</span></p><p class="c1 c2"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c1 c2"><span class="c0"></span></p><h1 class="c5" id="h.f99a94cf6cb7"><span class="c6">Overview</span></h1><p class="c1 c2"><span class="c0"></span></p><p class="c1 c16"><span class="c0">This homework was an involved and hands-on approach into the world of path tracing. Through building up basics such as ray generation, scene intersection, and building a bounding volume hierarchy, I was able to actually practice and implement myself the things I have learned and reviewed in lectures. And through the use of the GUI, I was able to physically see the effects of such techniques render hyper complex objects with thousands of primitives in less than a second. And the latter half of the homework dived into some advanced topics such as methods of Illumination both directly and globally as well as reducing the amount of noise generated through adaptive sampling. Probably the most interesting takeaway for me is the newfound appreciation I gained for the complexity of simulatic realistic/semi-realistic lighting and materials in virtual environments. Being able to not only shine light from a source point but also bounce it off a wall to create a more well lit image was super interesting. This understanding of simple lighting techniques gave me much more respect for game engines that are able to render scenes with multiple more magnitudes of complexity.</span></p><p class="c1 c2"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c1 c2"><span class="c0"></span></p><h1 class="c5" id="h.wubrwu4fsop3"><span>Part 1</span><span class="c6">: Ray Generation and Scene Intersection</span></h1><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c3">Ray generation and primitive intersection parts of the rendering pipeline</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">First, the ray generation. Simply put, anything we see in the image rendered is effectively a ray from our eye (camera) into the virtual world. This is done in several steps.As we have learned before, an image is just a collection of pixels being colored a certain way. For each pixel, we generate some number of rays (number given by user input). This is done in the raytrace function. Each sample ray generated is simply a random ray that starts from the box (x, y) to (x + 1, y + 1). I then call generate_ray which is part of the inherent camera that exists in our world. Generate_ray simply translates the x,y coordinates down by 0.5 so that the middle of the image is centered at 0,0 and then I upscale the coordinates by two such that the edges of the image are at (1,1) and (-1, -1). I then scale the image a factor of tan(hFov *0.5) to mimic how the ray goes into our world. Finally multiplying by a camera to world rotation matrix generates the ray. We estimate the lighting from this ray (in part 3), and then take the average of all the rays coming from this pixel. </span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">The primitive intersection parts of the pipeline are mechanical but are relatively simple. Above when we estimate the lighting from a certain ray, we do so by intersecting the ray with all the primitives (for now) to see which primitive the ray hits first. The respective information is then stored in the intersection struct. To check for an intersect with a primitive (in our case a triangle or sphere) we essentially just solve the ray-plane equation for t or ray-sphere equation for t1 and t2. </span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c3">Triangle intersection algorithm explanation</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">In this homework we work with two types of primitives, triangles and spheres. The way I see if a given ray intersects the triangle is using the method given in lecture. I first check if the ray intersects the plane that the triangle exists on. This can be checked by taking the dot products of the normal vector of the plane and the direction vector of the ray (it will be 0 if they do not intersect). If it does, then there exists a point that the ray hits the plane, call this point P. I then check using barycentric coordinates and a method identical to triangle rasterization in HW 1 to see if point P exists within the triangle. If it does then i update the intersection struct values to represent the ray hitting the primitive. I also update the max_t for the ray to ensure I don&rsquo;t check any other primitives that exists after this intersection. </span></p><p class="c1 c2"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Images for a few small dae files:</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">CBspheres_lambertian.dae:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 380.50px; height: 282.44px;"><img alt="" src="images/image69.png" style="width: 380.50px; height: 282.44px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">teapot.dae</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 565.00px; height: 318.61px;"><img alt="" src="images/image46.png" style="width: 600.00px; height: 407.00px; margin-left: 0.00px; margin-top: -88.39px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">cow.dae</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 353.00px; height: 539.00px;"><img alt="" src="images/image55.png" style="width: 353.00px; height: 539.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><h1 class="c5" id="h.tpplhmfnj39i"><span class="c6">Part 2: Bounding Volume Hierarchy</span></h1><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c3">BVH construction algorithm</span></p><p class="c1"><span class="c0">My initial BVH algorithm without much optimization is a relatively simple one.</span></p><p class="c1"><span class="c0">I take my input data, which is a bunch of primitives, and the goal is to make a tree structure that allows for more efficient ray tracing since a ray will most likely not hit many of the primitives. </span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">The algorithm starts at BVHAccell::construct_bvh. This functions takes in an iterator to the start and end of a primitives list of which we should create a BVH for, as well as a max leaf size. The way my algorithm works is by first iteration through the list of primitives. If the number of primitives is less than the max leaf size, then I simply return a new BVH leaf node with this information. It is important to note that any leaf node must have non-null values for its start and end. On the other hand, if the iteration detects more than max_leaf_size primitives then it is our job to split the list into 2 halves. Then based on the heuristic described below, I split the data into two partitions and call the function again to create the left and right node of the current node. Important, at each step I also calculate a bounding box of all the primitives that allows for ray-Bbox intersection in the next steps.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c3">Heuristic</span></p><p class="c1"><span>The heuristic I chose to best split the data is to first determine the bounding box of all the centroids of the primitives (not the primitives themselves). I then pick the axis that is the longest. For example, if my bounding box of centroids was (2, 4, -8), then I would choose the z axis as it has the greatest change and is &ldquo;able to split the most&rdquo;. I chose this heuristic as using the bounding box of the primitives themselves does not ensure that the list of primitives gets split because there exists cases when the centroids of all primitives lie in one half of the bounding box, resulting in an infinite recursion. My method fixes this as we are guaranteed to have at least 2 nodes in our current list of primitives and thus our bounding box is guaranteed to be non-trivial (with a primitive located at opposite ends of the bbox). As such a plane that runs along a midpoint axis is guaranteed to split at least one node off. This will ensure we don&rsquo;t run into an infinite recursion</span><hr style="page-break-before:always;display:none;"></p><p class="c1"><span class="c0">A few large dae files that can only be rendered with BVH</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">blob.dae</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 431.00px; height: 400.00px;"><img alt="" src="images/image61.png" style="width: 431.00px; height: 400.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">maxplanck.dae</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 343.50px; height: 480.47px;"><img alt="" src="images/image2.png" style="width: 343.50px; height: 480.47px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">CBlucy.dae</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 522.00px; height: 393.00px;"><img alt="" src="images/image42.png" style="width: 522.00px; height: 393.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Speedup without and with BVH on cow.dae</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Without</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 411.50px; height: 310.60px;"><img alt="" src="images/image3.png" style="width: 411.50px; height: 310.60px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">With BVH:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 446.50px; height: 326.29px;"><img alt="" src="images/image23.png" style="width: 446.50px; height: 326.29px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><p class="c1"><span class="c0">Speedup without and with BVH on teapot.dae</span></p><p class="c1"><span class="c0">without:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 467.50px; height: 348.38px;"><img alt="" src="images/image8.png" style="width: 467.50px; height: 348.38px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">With bvh:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 448.50px; height: 333.50px;"><img alt="" src="images/image68.png" style="width: 448.50px; height: 333.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c3">Present your results in a one-paragraph analysis.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">It can be seen that the construction of the BVH makes rendering time super fast. I am working on a relatively old windows laptop which meant rendering without BVH was taking a very very long time. To see the true effects of our speedup, we can take a look at cow.dae. The cow has various appendeges and limbs and a head. It would not make sense to intersect a ray that is clearly aiming toward its head with primitives that make up the cows legs. By pruning these bounding boxes, we see a drastic speedup in terms of rendering time. However, on the flipside we do see that the construction time is now nonzero. Before, since our BVH was just one flat we did not just to do any complex construction. However, now we must preprocess our data which consists of making the entire BVH structure. For the cow, it means splitting the cow between front and back, left and right, up and down repeatedly which takes a while. This is why the construction times are vastly different (0.0001 vs 0.0023 seconds). Ultimately, though, the tradeoff is still worth it as we are saving many orders of magnitude more time in rendering time.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c1 c2"><span class="c0"></span></p><h1 class="c5" id="h.1vk2uv1x1vr"><span>Part 3: Direct Illumination</span></h1><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c3">Uniform hemisphere sampling</span></p><p class="c1"><span class="c0">To implement direct lighting using uniform hemisphere sampling, I used the method described in lecture slides. </span></p><p class="c1"><span class="c0">Essentially for any given ray, we are tasked with solving</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 290.00px; height: 38.00px;"><img alt="" src="images/image67.png" style="width: 290.00px; height: 38.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Since we don&rsquo;t actually compute the integral, we instead sample uniformly from the hemisphere around the point and then average the results.</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 223.00px; height: 47.00px;"><img alt="" src="images/image6.png" style="width: 223.00px; height: 47.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0">Simply put, we calculate the average contribution from a light source to a point over all the samples we generate. For each of the sample, we check to see if the ray hits the light source and if it does add this to our output vector.</span></p><p class="c1"><span>To implement this, we initialize a L_out vector that stores the output. For each iteration, we generate a sample using hemisphereSampler-&gt;get_sample().Using this sample&rsquo;s direction, we then intersect this ray. If this ray does actually hit something, then we get that primitives emission value and add it to our output vector (emission values are only non-zero for emitting surfaces or light). When adding it to our output vector, we have to remember to scale by cos_theta(w_in) as per the function stated above. Finally we scale down the output vector by the number of samples generated</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c3">Light importance sampling</span></p><p class="c1"><span class="c0">Directing lighting using light importance is a little different from uniform sampling. Instead of the above approach, we now loop through our scene&rsquo;s light sources and calculating how much light each light source contributes to our current position. This can be done easily with scene-&gt;lights, which returns a vector of SceneLights*. If the light is an area light, then we take ns_area_light samples. Otherwise it means it is a point light in which case we only take one sample. Whichever the case, we loop through the number of samples. For each sample generated from each light, we perform a similar action to above, where we check to see if our ray actually hits our isect and is not blocked by something else. We only add the light value generated if it is unobstructed.We do this by checking the cos_theta value or alternatively the w_in.z value to see if it is greater than or equal to 0. We then add it to our output vector after scaling the emission the cos_theta value </span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c3">screenshots of uniform hemisphere sampling</span></p><p class="c1"><span class="c0">s = 16, l = 8</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 434.62px; height: 322.31px;"><img alt="" src="images/image12.png" style="width: 434.62px; height: 322.31px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">s =64 l = 32</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 479.00px; height: 356.00px;"><img alt="" src="images/image75.png" style="width: 479.00px; height: 356.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c1 c2"><span class="c3 c9"></span></p><p class="c1"><span class="c3">screenshots of light importance sampling</span></p><p class="c1"><span class="c0">s = 16, l = 8</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 474.00px; height: 347.00px;"><img alt="" src="images/image14.png" style="width: 474.00px; height: 347.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">s =64 l = 32:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 472.00px; height: 350.00px;"><img alt="" src="images/image60.png" style="width: 472.00px; height: 350.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c3">Comparison of the noise levels in soft shadows when rendering with 1, 4, 16, and 64 light rays</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">s = 1, l = 1</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 470.00px; height: 351.00px;"><img alt="" src="images/image49.png" style="width: 470.00px; height: 351.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">s = 1, l = 4:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 471.00px; height: 351.00px;"><img alt="" src="images/image54.png" style="width: 471.00px; height: 351.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">s = 1, l = 16:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 465.00px; height: 353.00px;"><img alt="" src="images/image47.png" style="width: 465.00px; height: 353.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">s = 1, l = 64:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 470.00px; height: 351.00px;"><img alt="" src="images/image65.png" style="width: 470.00px; height: 351.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><p class="c1"><span class="c3">Compare the noise levels in soft shadows</span></p><p class="c1"><span class="c0">As we change the l value, or the value that represents the number of light rays at each image, we see that the noisiness of the image decreases. Specifically, we see that there is less variation between pixels that are right next to each other. Overall, it produces an image that appears less grainy as we increase the number of light samples. This makes intuitive sense as we are testing more samples for every light source thus the amount of spots where no light hits becomes less. As we increase the number of samples to infinity, we can confirm that we are converging to the true value of the integral from our Monte Carlo estimator.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c3">Uniform hemisphere sampling vs Lighting sampling</span><span class="c0">:</span></p><p class="c1"><span class="c0">When comparing Uniform hemisphere sampling vs lighting sampling, it can be seen that the uniform method has a little bit more noise than lighting sampling when compared at the same s-level and l-level. This difference in noise level can be attributed to the fact that uniform sampling does not prioritize rays that contribute more significantly to the final color (which are the rays from the light). Light sampling instead only cares about the rays from a light source, by its namesake. A potential fix might be to increase the sampling rate as a whole (s - level).</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c6">Part 4: Global Illumination</span></p><p class="c1"><span class="c3">Some images rendered with global (direct and indirect) illumination</span></p><p class="c1"><span class="c0">CBbunny.dae</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">direct only:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 458.50px; height: 340.50px;"><img alt="" src="images/image16.png" style="width: 458.50px; height: 340.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">global:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 458.50px; height: 343.68px;"><img alt="" src="images/image48.png" style="width: 458.50px; height: 343.68px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><p class="c1"><span class="c0">CBspheres_lambertian.dae</span></p><p class="c1"><span class="c0">direct only:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 398.00px; height: 296.00px;"><img alt="" src="images/image72.png" style="width: 398.00px; height: 296.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">global:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 399.00px; height: 299.00px;"><img alt="" src="images/image76.png" style="width: 399.00px; height: 299.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c3">One Scene with only direct and only indirect with 1024 samples per pixel.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Using CBspheres_lambertian.dae</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">direct:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 398.00px; height: 296.00px;"><img alt="" src="images/image72.png" style="width: 398.00px; height: 296.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">indirect only:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 398.00px; height: 297.00px;"><img alt="" src="images/image41.png" style="width: 398.00px; height: 297.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Comparison:</span></p><p class="c1"><span class="c0">When comparing these two images we can notice several differences. First and foremost is the color of the light on top. In direct the light is white when indirect is black. This makes intuitive sense as direct lighting contains zero_bounce which is only light surfaces. Which can be seen in the below image that we got after we rendered CB spheres after Task 3.2</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 273.71px; height: 203.52px;"><img alt="" src="images/image32.png" style="width: 273.71px; height: 203.52px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span>Another stark difference is the fact that the color of the walls is now shown on the surface of the balls. This happens because after one bounce (which is when the light hits the blue wall), that light bounces off of the blue wall and hits the sphere. The final difference noted is the fact that the light (white) part of the sphere is on the bottom rather than the top like direct lighting. This is because in direct lighting the light shines directly from the light to the top of the sphere directly. However, in indirect lighting this cannot happen as we only count light greater than or equal to 2 bounces. Thus the majority of light in indirect will be seen when the light from the ceiling bounces off the ground and reaches the sphere. (A way to think about this effect is making the entire ground a softer light source and running direct lighting on this new scene.</span><hr style="page-break-before:always;display:none;"></p><p class="c1"><span class="c9 c3">CBbunny.dae rendering the mth bounce of light with different -m max_ray_depth and isAccumBounces=false and 1024 samples per pixel</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">m=0:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 402.00px; height: 299.00px;"><img alt="" src="images/image62.png" style="width: 402.00px; height: 299.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">m=1:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 402.00px; height: 297.00px;"><img alt="" src="images/image27.png" style="width: 402.00px; height: 297.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">m=2:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 399.00px; height: 299.00px;"><img alt="" src="images/image15.png" style="width: 399.00px; height: 299.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">m=3:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 400.00px; height: 301.00px;"><img alt="" src="images/image35.png" style="width: 400.00px; height: 301.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">m=4:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 402.00px; height: 301.00px;"><img alt="" src="images/image26.png" style="width: 402.00px; height: 301.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">m=5:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 400.00px; height: 303.00px;"><img alt="" src="images/image39.png" style="width: 400.00px; height: 303.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">For m=2, we see that the bottom of the bunny is really well-lit. This is for the same reason mentioned in the comparison between direct and indirect only for the CBspheres. In short, the majority of the light in 2 bounces will be the light that comes from the ceiling, bounces off of the floor, and falls on the bunny (which happens on this bottom). </span></p><p class="c1"><span class="c0">For m=3, we see that the various inner grooves of the bunny are now lit up more. For example, the inside of its ears, the fold next to its leg, and its neck area are all more lit now. This makes sense as the light is bouncing on more time and sort of &ldquo;filling in&rdquo; all the places that the light has not been able to reach thus far. Specifically, those spots would be the grooves in the aforementioned spots on the bunny.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c3">How it contributes to the quality of the rendered image compared to rasterization</span></p><p class="c1"><span>When compared to rasterization, which usually only has one layer of color when being rendered, the bunny and the spheres now have multiple layers of color on top of each other. The reason why is due to the light source and more importantly how the light interacts with different elements in the scene (ex bouncing, reflecting, diffusing). As such, rasterization, especially as we&rsquo;ve seen in the first homework, generally ends up looking less realistic as it has no shadows, depth, or lighting, all of which are components for realism.</span></p><p class="c1 c2"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c3">Compare rendered views with max_ray_depth set to 0, 1, 2, 3, 4, and 5(the -m flag)</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">m=0:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 479.00px; height: 358.00px;"><img alt="" src="images/image34.png" style="width: 479.00px; height: 358.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">m=1:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 481.00px; height: 360.00px;"><img alt="" src="images/image44.png" style="width: 481.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0">m=2:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 475.00px; height: 360.00px;"><img alt="" src="images/image25.png" style="width: 475.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">m=3:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 481.00px; height: 359.00px;"><img alt="" src="images/image77.png" style="width: 481.00px; height: 359.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">m=4:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 482.00px; height: 362.00px;"><img alt="" src="images/image57.png" style="width: 482.00px; height: 362.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">m=5:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 483.00px; height: 362.00px;"><img alt="" src="images/image11.png" style="width: 483.00px; height: 362.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">When comparing the last 5 images, to the naked eye, there does not seem to be much change past m=2. This is probably because the amount of light being added from additional bounces of light is super marginal compared to the initial 1 or 2 bounces. Also when compared to the accumulate is false, we can see that the overhead light for all images after m=0 is now one because we take the cumulative sum of all previous bounces rather than just the specific m value. From m=2 to m=3, we can see some corners shading be a little more smoothed out as well as brighter. This may be because of the additional bounces now reaching the corner which were not possible or just not enough to allow for the corner to be lit. As mentioned before there are almost no differences to the naked eye for the following m value pictures.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c3">Output the </span><span class="c3 c12">Russian Roulette rendering</span><span class="c3">&nbsp;with max_ray_depth set to 0, 1, 2, 3, 4, and 100</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">m = 0</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 397.00px; height: 298.00px;"><img alt="" src="images/image5.png" style="width: 397.00px; height: 298.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">m=1:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 405.00px; height: 301.00px;"><img alt="" src="images/image10.png" style="width: 405.00px; height: 301.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">m=2:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 402.00px; height: 302.00px;"><img alt="" src="images/image29.png" style="width: 402.00px; height: 302.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">m=3:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 402.50px; height: 302.08px;"><img alt="" src="images/image45.png" style="width: 402.50px; height: 302.08px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">m=4:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 387.88px; height: 292.10px;"><img alt="" src="images/image13.png" style="width: 387.88px; height: 292.10px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">m=100:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 396.50px; height: 298.19px;"><img alt="" src="images/image43.png" style="width: 396.50px; height: 298.19px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c3">Pick one scene and compare rendered views with various sample-per-pixel rates, including at least 1, 2, 4, 8, 16, 64, and 1024</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Using CBbunny.dae:</span></p><p class="c1"><span class="c0">s = 1:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 400.00px; height: 300.00px;"><img alt="" src="images/image36.png" style="width: 400.00px; height: 300.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">s=2</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 402.50px; height: 303.35px;"><img alt="" src="images/image79.png" style="width: 402.50px; height: 303.35px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">s=4:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 403.00px; height: 301.00px;"><img alt="" src="images/image52.png" style="width: 403.00px; height: 301.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">s=8:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 403.50px; height: 301.78px;"><img alt="" src="images/image24.png" style="width: 403.50px; height: 301.78px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">s=16:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 401.00px; height: 300.00px;"><img alt="" src="images/image38.png" style="width: 401.00px; height: 300.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">s=64:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 403.50px; height: 302.83px;"><img alt="" src="images/image59.png" style="width: 403.50px; height: 302.83px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">s=1024:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 404.00px; height: 300.00px;"><img alt="" src="images/image71.png" style="width: 404.00px; height: 300.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">As we increase our sample rate from 1 to 1024, it becomes clear that the noise level of each image becomes drastically reduced. This makes intuitive sense as now every we are generating more rays overall, as thus have less of a chance for our rays to not hit something a light source and return 0 (black). Moreover, it can be seen that the images also gradually get brighter. This might be an effect of reducing noise as we see less black noise, and thus our image as a whole seems brighter, even when the image itself may actually be just the same brightness level. There does exist tradeoff however, as rendering the s = 1024 image took a very long time. Thus it is important to consider the necessity of generating super clean looking images with the computational resources available.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c1 c2"><span class="c0"></span></p><h1 class="c5" id="h.x1e1fdiwtu5g"><span class="c6">Part 5: Adaptive Sampling</span></h1><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c3">Adaptive sampling explanation</span></p><p class="c1"><span class="c0">As a high level overview, adaptive sampling tries to focus our computational resources on the areas that need a lot of sampling because they may vary with any additional samples generated. This is contrasted to areas where it converges very quickly and any other sampling done for that region is effectively wasting our computer&rsquo;s time and resources. This is what adaptive sampling tries to implement as we want to only sample until we don&rsquo;t have to anymore. While that may seem like circular logic, we implement a heuristic to measure the convergence of pixel&rsquo;s ray tracing.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">As per the spec, we use the heuristic I:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 125.00px; height: 51.00px;"><img alt="" src="images/image4.png" style="width: 125.00px; height: 51.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">If we can confidence deduce that I is small enough (meaning the variance in sampling is small with 95% confidence), then we should stop sampling because, again, we can be 95% confident that additional samples will lie in the already computed distribution of rays.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Specifically, we want to repeatedly check to see if</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 196.00px; height: 32.00px;"><img alt="" src="images/image7.png" style="width: 196.00px; height: 32.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">However, as per the spec, we don&rsquo;t want to check this at every iteration as computing this will probably cost us more time that it may save. As such, we compute the value of the heuristic at intervals or batches. </span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c3">Walk through your implementation of the adaptive sampling.</span></p><p class="c1"><span class="c0">My implementation of adaptive sampling is identical to the format outlined above.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">My changes are made in raytrace_pixel in which my code has already existed from part 1. </span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">In the beginning, I initialize 3 variables that I will need to repeatedly update:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 136.00px; height: 60.00px;"><img alt="" src="images/image19.png" style="width: 136.00px; height: 60.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0">s1 is the sum of our vectors</span></p><p class="c1"><span class="c0">s2 is the squared sum of our vectors</span></p><p class="c1"><span class="c0">i is our current iteration</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Then, by adding this code chunk:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 421.00px; height: 213.00px;"><img alt="" src="images/image18.png" style="width: 421.00px; height: 213.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">which is an exact copy of the two equations found above, I am able to calculate the heuristic before running the rest of the raytrace iteration. As can be seen, I break if the condition is met and return the current L_out divided by the number of samples I have run through (which in my case is i + 1).</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c9 c3">Pick two scenes and render them with at least 2048 samples per pixel. Show a good sampling rate image with clearly visible differences in sampling rate over various regions and pixels</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">For CBbunny.dae:</span></p><p class="c1"><span class="c0">Adaptive Image:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 424.50px; height: 318.98px;"><img alt="" src="images/image31.png" style="width: 424.50px; height: 318.98px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Rate Image:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 430.50px; height: 324.23px;"><img alt="" src="images/image33.png" style="width: 430.50px; height: 324.23px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">For CBSpheres_lambertian.dae:</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Adaptive Image:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 403.00px; height: 302.00px;"><img alt="" src="images/image9.png" style="width: 403.00px; height: 302.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 400.00px; height: 301.00px;"><img alt="" src="images/image58.png" style="width: 400.00px; height: 301.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c1 c2"><span class="c0"></span></p><h1 class="c5" id="h.pb8w375cja6y"><span class="c6">Part 6: Extra Credit</span></h1><p class="c1 c2"><span class="c0"></span></p><h2 class="c15" id="h.n5iw1oij950f"><span class="c4">Challenge Level 1:</span></h2><p class="c1"><span class="c3">Create a more sophisticated pixel sampler that generates jittered or pseudorandom low-discrepancy samples.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Initially, The way I am sampling is generating num_samples complete random samples all within the pixel. However, these samples might end up problematically all in the same corner or in general be non representative. </span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">On the other hand, we do want some level of non-deterministic-ivity. As such, I chose to implement jittered sampling which is essentially dividing the pixel into num_samples little squares and then choosing a singular random sample from within each box.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 393.50px; height: 294.49px;"><img alt="" src="images/image53.png" style="width: 393.50px; height: 294.49px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">The code changes were pretty minimal. It consisted of calculating which minibox we were in for each sample. which was done by the following:</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 210.00px; height: 63.00px;"><img alt="" src="images/image56.png" style="width: 210.00px; height: 63.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Then using the random sampler, I now only random sampling within the mini box </span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">For reference the image of the CBspheres below has been generated after Task 3 is finished and thus global illum is not on.</span></p><p class="c1 c2"><span class="c9 c3"></span></p><p class="c1"><span class="c0">Before:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 484.00px; height: 359.00px;"><img alt="" src="images/image17.png" style="width: 484.00px; height: 359.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">After:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 481.00px; height: 357.00px;"><img alt="" src="images/image64.png" style="width: 481.00px; height: 357.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span>There does not seem to be a huge amount of difference in most of the picture. However, the gradient from the top of the ball to the bottom of the ball is somewhat smoother by a marginal amount. Moreover, when I rendered multiple times, the new version did not change that much, meaning its variance was relatively low. This might lead to faster convergence after part 5 is implemented. </span><hr style="page-break-before:always;display:none;"></p><p class="c1"><span class="c3">Implement the surface area heuristic for splitting in your BVH. Take some performance measurements on various scenes to determine when it performs better than more naive heuristics.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">To do this I first implemented a helper function that allows me to calculate the surface area of a potential bounding box created by a list of primitives. It is called get surface area and is implemented like the following:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 568.00px; height: 300.00px;"><img alt="" src="images/image50.png" style="width: 568.00px; height: 300.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0">I then used the formula given in lecture slides:</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 41.33px;"><img alt="" src="images/image78.png" style="width: 624.00px; height: 41.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0">Before calculating the heuristic, I made to first loop through all the axes, to find the best one to split on. On each axes, I sorted the primitives based on their centroid using custom comparator functions:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 465.00px; height: 73.00px;"><img alt="" src="images/image74.png" style="width: 465.00px; height: 73.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Finally, I computed the heuristic for each split </span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 25.33px;"><img alt="" src="images/image22.png" style="width: 624.00px; height: 25.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">And simply took the minimum split and made that my splitVal and splitAxis. This allowed me to keep my same code from before</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">This part significantly boosted my rendering times on larger daes.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">As a reminder these were my times with the simple BVH:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 446.50px; height: 326.29px;"><img alt="" src="images/image23.png" style="width: 446.50px; height: 326.29px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">These are my times when implementing a surface area heuristic</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 467.50px; height: 348.38px;"><img alt="" src="images/image28.png" style="width: 467.50px; height: 348.38px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c3">Implement more efficient construction and intersection routines for the BVH that replace the recursive calls with a stack and a while loop (you should use the C++ standard library&#39;s std::stack class). Compare performance in terms of construction time and scene rendering time.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Since both the construction and rendering are at their heart dfs calls, we can set up a dfs traversal algorithm. </span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">I set up the variables necessary for a traversal:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 264.00px; height: 69.00px;"><img alt="" src="images/image73.png" style="width: 264.00px; height: 69.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">And pretty much moved everything into a while loop using my stack:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 497.50px; height: 378.72px;"><img alt="" src="images/image40.png" style="width: 497.50px; height: 378.72px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Similar process was done for BVH construction as well. The only real logic change made was to use a global hit boolean instead of computing one for every single recursive (or in our case iterative step). </span></p><p class="c1 c2"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">This resulted in major speedups when rendering cow.dae. The speedups were not that much for the construction however the overhead of computation still exists as well as the actual timing of construction is already super super low. (For even the most complex of meshes, my construction times were already under a second) and thus speedups were harder to be seen</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">For reference these were my times with implementing a BVH with SAH (after the 2nd extra credit)</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 442.50px; height: 327.85px;"><img alt="" src="images/image28.png" style="width: 442.50px; height: 327.85px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">After implementing </span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 456.50px; height: 338.51px;"><img alt="" src="images/image1.png" style="width: 456.50px; height: 338.51px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Note that my BVH construction time is also a little bit lower, but not by that much.</span></p><p class="c1 c2"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c3">Implement a more memory efficient BVH by storing all the Primitive pointers in one large vector and only keeping index references into small contiguous chunks of this vector inside the leaves. Alternatively, think of and research other ways to compress the tree. Compare memory usage to the original data structure.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">As stated in Part 2 of this homework, my initial process was to find a splitVal and splitAxis and then take the primitives from the original vector and store them into two different left and right vectors that I declare.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 469.00px; height: 65.00px;"><img alt="" src="images/image30.png" style="width: 469.00px; height: 65.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">This creates a new list every single time and new references must be stored on the heap, which wastes a lot of memory.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">As such I made use of the iterators given. This helped me realize one super important factor: Anytime I am passing in an iterator start and end into a child function, that child function and any other grandchildren from that child will never interact with the rest of the other primitives. For example, once I partition my data, the left child and any children of the left child will never interact with the data in the right vector. </span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Thus after I find the split val and consequently, the split axis, I then sort based on this split axis. after all heuristic calculations are done. Then, instead of making a completely new left and right vector, I simply pass in the following into my children BVH construction methods at the bottom.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 514.00px; height: 46.00px;"><img alt="" src="images/image70.png" style="width: 514.00px; height: 46.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">For reference this is what it was before</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 563.00px; height: 49.00px;"><img alt="" src="images/image63.png" style="width: 563.00px; height: 49.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">This cuts down on memory usage by a factor of 2 as we made making a new list of length n at every step of recursion and we are using a divide and conquer method of log 2 so our total memory work is T(2n). Now since we are not manipulating anything and only storing our original vector of primitives, we now only have a memory size of T(n).</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c3">Add some GUI features to make our live-update interface better. You could use mouse clicks to focus the rendering around a particular area or to draw a rectangle around a region of interest that should get more samples, you could save incremental results to disk when rendering slow scenes, you could improve our sample buffer data structure to allow for multiple passes of sampling (so save every sample given instead of just the average), etc. Discuss what you added and show screenshots if applicable.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">I implemented the repeat timing feature. Since several portions of this project had us make optimizations on existing implementations and to physically time it, I found myself running the same command or rerendering multiple times to get enough samples. As such, I implemented the functionality so that when you press L, the picture that you wish to render gets rendered 5 times (can easily be changed), and it gives you an output of the total and average time.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 293.33px;"><img alt="" src="images/image21.png" style="width: 624.00px; height: 293.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><h2 class="c15 c17" id="h.n5g8byc0g5y1"><span class="c4"></span></h2><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c1 c2"><span class="c0"></span></p><h2 class="c15" id="h.ujbgjegq078e"><span class="c4">Challenge Level 3:</span></h2><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c3">Implement non-axis-aligned bounding boxes, and show it actually benefits ray traversal.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">The first thing to note when implementing non axis aligned bounding boxes (or non AABB) is that any box in our 3-d coordinate space can be represented with 3 rays or for more memory efficiency, 4 vectors. These 4 vectors are:</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 179.00px; height: 133.00px;"><img alt="" src="images/image66.png" style="width: 179.00px; height: 133.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Which are now added in bbox.h</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">o is effectively the min, or the starting point of our bbox.</span></p><p class="c1"><span class="c0">d1,d2,d3 are difference vectors along the 3 axes of our box (not the cardinal x,y,z axes). Thus to get the max of the box, we would simply use o + d1 + d2 + d3.</span></p><p class="c1"><span class="c0">Every single one of the 8 corners can be made with from subset of these vectors.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Another thing to note is that any box in space is simply a rotation of some AABB. Thus I defined another final vector that represents the angles for each of the x, y, and z axes by which I rotate an AABB to get to this bbox.</span></p><p class="c1"><span class="c0">I also implemented a get volume function which is simply a product of the norms of d1 d2 and d3. </span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Thus we can define rotation matrices about the X, Y, and Z axis given a theta.</span></p><p class="c1"><span class="c0">Around Z:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 169.00px; height: 68.00px;"><img alt="" src="images/image37.png" style="width: 169.00px; height: 68.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Around Y:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 171.00px; height: 64.00px;"><img alt="" src="images/image20.png" style="width: 171.00px; height: 64.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">around X axis:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 167.00px; height: 67.00px;"><img alt="" src="images/image51.png" style="width: 167.00px; height: 67.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Given all of these, our job is to find the values of thetax, thetay, and thetaz, which define the rotation of the bounding box which gives us the minimum volume.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span>To reduce complexity, I chose to only check theta values in increments of 30. In practice this might be closer to 5 or 10.</span></p></body></html>